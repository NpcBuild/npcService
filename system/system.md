# 限流（优雅切换）
1. 使用Guava实现单机令牌桶限流
2. 使用Redis实现分布式限流
# 获取请求中的用户信息
1. 使用拦截器和 ThreadLocal：
   创建一个拦截器，在请求进入时解析 token 并将用户信息存储到 ThreadLocal 中。然后在需要的地方直接从 ThreadLocal 中获取用户信息。需要注意 ThreadLocal 的使用，确保在请求结束时进行清理。
2. 使用全局拦截器和 ThreadLocal 副本：
   在拦截器中获取用户信息后，创建副本存储在 ThreadLocal 中，而不是直接存储原始对象。确保在线程池等情况下不会出现数据交叉。
3. 使用 Spring Security：
   集成 Spring Security 框架来处理身份验证和授权。Spring Security 提供了强大的机制来处理用户信息，通过 SecurityContextHolder 可以方便地获取当前用户信息。
4. ~~在每个方法中获取：
   在每个业务方法中直接获取请求的 token 并解析用户信息。这种方式简单直接，但可能导致重复代码。~~
5. ~~使用自定义注解和参数解析器：
   创建一个自定义注解，然后通过参数解析器在方法参数中注入用户信息。这可以减少重复代码，但需要在每个方法上添加注解。~~
> 第一种和第二种都涉及使用拦截器和 ThreadLocal 来在请求中存储用户信息，但在细节上有一些差异
>
> 第一种的主要思想是，拦截器会在每个请求进入控制器方法之前执行，它负责解析 token 并将用户信息存储到 ThreadLocal 中。然后，你可以在方法内部直接从 ThreadLocal 中获取用户信息。
>
> 第二种在第一种方式的基础上引入了副本。在拦截器中，不直接将原始用户信息存储在 ThreadLocal 中，而是创建一个副本，并将副本存储在 ThreadLocal 中。这样每个线程都有自己的副本，避免了线程间数据共享的问题。
- 第一种方式直接存储原始用户信息，可能导致在多线程环境下出现数据交叉问题，需要确保在线程池等情况下正确清理 ThreadLocal。
- 第二种方式创建副本存储用户信息，避免了数据交叉问题，但可能会增加一些内存开销。相对更安全，尤其在复杂的并发环境中，但相应地也会略微复杂一些。
